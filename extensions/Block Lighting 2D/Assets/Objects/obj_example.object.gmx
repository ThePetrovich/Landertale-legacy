<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Sets the font for the information on screen to ft_example.
draw_set_font(ft_example);

// Disables the application surface for higher fps. This is optional and can be commented out.
application_surface_enable(false);

// Defines the block size and how many blocks that fit horizontally and vertically in the window.
block_width = 16; block_height = 16;
blocks_horizontally = room_width / block_width; blocks_vertically = room_height / block_height;

// Initializes 2D Block Lighting.
bl_init();

// Creates a BL (block lighting) rectangle which will represent the rectangular area we draw lighting to. Type 4 is used.
bl_rectangle = bl_rectangle_create(blocks_horizontally, blocks_vertically, block_width, block_height, 4);

// Creates a DS grid with block data. True represents a block, false represents no block. This is sent to a BL rectangle later for it to know how to lay out the lighting.
block_grid = ds_grid_create(blocks_horizontally, blocks_vertically);

// Creates a variable for a surface which will contain the blocks without lighting. This is just how the example does it, different ways of visualizing blocks can be used.
sf_blocks = -1;

// To mask out lighting that overlaps with the air, an additional surface is used. You can set this to true (nicer) or false (faster).
mask_lighting_against_blocks = true;
sf_mask_lighting_against_blocks = -1;

// Loads blocks. This is just so there are some blocks there to start off with. It changes the values of our block_grid to show some terrain.
var f = file_text_open_read("preset");
ds_grid_read(block_grid, file_text_read_string(f));
file_text_close(f);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Lets the user end the game.
if (keyboard_check_pressed(vk_escape)) game_end();

// Lets the user place and break blocks.
if (mouse_button == mb_left || mouse_button == mb_right) {
    // Gets the coordinate of the block the mouse is above.
    var t_x = mouse_x div block_width, t_y = mouse_y div block_height;
    
    // Places a block if left mouse is held, otherwise destroys it.
    if (mouse_button == mb_left) block_grid[# t_x, t_y] = true; else block_grid[# t_x, t_y] = false;
    
    // Updates block surface.
    draw_enable_alphablend(false);
        surface_set_target(sf_blocks);
            if (mouse_button == mb_left) example_block_redraw(t_x, t_y); else example_block_erase(t_x, t_y);
            example_block_redraw(t_x, t_y - 1);
            example_block_redraw(t_x - 1, t_y);
            example_block_redraw(t_x + 1, t_y);
            example_block_redraw(t_x, t_y + 1);
        surface_reset_target();
    draw_enable_alphablend(true);
    
    // Updates the actual lighting using 2D Block Lighting.
    bl_rectangle_update(bl_rectangle, block_grid, t_x, t_y, 1, 1);
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Creates the block surface if it doesn't exist, and draws all blocks to it.
if (!surface_exists(sf_blocks)) {
    sf_blocks = surface_create(room_width, room_height);
    surface_set_target(sf_blocks);
        draw_enable_alphablend(false);
            draw_clear_alpha(c_black, 0);
            var t_x, t_y;
            for (t_y = 0; t_y &lt; blocks_vertically; ++t_y)
            for (t_x = 0; t_x &lt; blocks_horizontally; ++t_x)
                if (block_grid[# t_x, t_y]) draw_sprite(spr_example_block, example_block_get_image_index(t_x, t_y), t_x * block_width, t_y * block_height);
        draw_enable_alphablend(true);
    surface_reset_target();
}

// The blocks and lighting is drawn. With the first BL rectangle types you probably want the lighting to be drawn before the blocks, in that case you can change the code below.
if (mask_lighting_against_blocks) {
    // Masks lighting. This is not necessary, but can make things look nicer.
    // How it works: The block surface is copied to a another surface. Then the lighting is drawn with a multiply blend mode so that only color is changed, and not the alpha.
    // So since the air has alpha 0, it will still have alpha 0 afterward. Then this surface is drawn to the screen.
    if (!surface_exists(sf_mask_lighting_against_blocks)) sf_mask_lighting_against_blocks = surface_create(room_width, room_height);
    surface_copy(sf_mask_lighting_against_blocks, 0, 0, sf_blocks);
    surface_set_target(sf_mask_lighting_against_blocks);
        bl_rectangle_draw(bl_rectangle, block_grid, 0, 0, blocks_horizontally, blocks_vertically, 0, 0, c_black);
    surface_reset_target();
    draw_surface(sf_mask_lighting_against_blocks, 0, 0);
} else {
    // This does not mask lighting. It first draws the blocks, then the lighting.
    draw_surface(sf_blocks, 0, 0);
    bl_rectangle_draw(bl_rectangle, block_grid, 0, 0, blocks_horizontally, blocks_vertically, 0, 0, c_black);
}

// Draws information to the screen.
draw_set_color(c_black);
draw_text(10, 10, "FPS: " + string(fps) + "#Left mouse to place blocks, right mouse to break blocks.");
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
